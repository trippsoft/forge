// Copyright (c) Forge
// SPDX-License-Identifier: MPL-2.0

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/trippsoft/forge/pkg/errorwrap"
)

const (
	fileHeader = `// Code generated by scriptimport.  DO NOT EDIT.`
)

var (
	extensionConfigs = map[string]*parserConfig{
		".ps1": {
			commentPrefix:         "#",
			nonLineBreakingTokens: []string{"{"},
			lineEndingToken:       ";",
		},
		".sh": {
			commentPrefix:         "#",
			nonLineBreakingTokens: []string{"then", "else", "{", "do"},
			lineEndingToken:       ";",
		},
	}
	backtickRegex = regexp.MustCompile("(`+)")
)

func main() {
	args := os.Args[1:]

	if len(args) < 2 {
		println("Usage: scriptimport <package-name> <script-file>")
		os.Exit(1)
	}

	packageName := args[0]
	scriptFilePath := args[1]

	scriptFileName := filepath.Base(scriptFilePath)
	scriptExtension := filepath.Ext(scriptFileName)

	variableName := fmt.Sprintf("%sScript", snakeCaseToPascalCase(strings.TrimSuffix(scriptFileName, scriptExtension)))

	destinationFilePath := fmt.Sprintf("%s.go", scriptFileName)

	destinationFile, err := os.Create(destinationFilePath)
	if err != nil {
		fmt.Printf("Error creating destination file: %v\n", err)
		os.Exit(1)
	}

	stringBuilder := &strings.Builder{}

	stringBuilder.WriteString(fileHeader)

	parserConfig, exists := extensionConfigs[scriptExtension]

	if !exists {
		stringBuilder.WriteString("\n\n// Unsupported script extension: ")
		stringBuilder.WriteString(scriptExtension)
		stringBuilder.WriteString("\n")

		stringBuilder.WriteString("package ")
		stringBuilder.WriteString(packageName)
		stringBuilder.WriteString("\n\n")

		destinationFile.WriteString(stringBuilder.String())
		destinationFile.Close()
		os.Exit(0)
	}

	scriptContent, err := os.ReadFile(scriptFilePath)
	if err != nil {
		stringBuilder.WriteString("// Error reading script file: " + err.Error() + "\n")

		stringBuilder.WriteString("package ")
		stringBuilder.WriteString(packageName)
		stringBuilder.WriteString("\n\n")

		destinationFile.WriteString(stringBuilder.String())
		destinationFile.Close()
		os.Exit(1)
	}

	preScriptComments, parsedLines, nonCommentFound, err := parseScriptIntoLines(scriptContent, parserConfig)

	if len(preScriptComments) > 0 {
		stringBuilder.WriteString("\n\n")
	}

	for i, comment := range preScriptComments {

		if comment != "" {
			stringBuilder.WriteString("// ")
			stringBuilder.WriteString(comment)
		}

		if i < len(preScriptComments)-1 {
			stringBuilder.WriteString("\n")
		}
	}

	stringBuilder.WriteString("\n\n")

	stringBuilder.WriteString("package ")
	stringBuilder.WriteString(packageName)
	stringBuilder.WriteString("\n\n")

	if !nonCommentFound {
		stringBuilder.WriteString("// No executable lines found in the script.\n")

		if err != nil {
			stringBuilder.WriteString("\n// Errors encountered during parsing:\n")
			for _, parseErr := range errorwrap.UnwrapErrors(err) {
				stringBuilder.WriteString("//     " + parseErr.Error() + "\n")
			}
		}
		destinationFile.WriteString(stringBuilder.String())
		destinationFile.Close()
		os.Exit(0)
	}

	stringBuilder.WriteString("const ")
	stringBuilder.WriteString(variableName)
	stringBuilder.WriteString(" = `` +\n")

	parseScript(stringBuilder, parsedLines)

	if err != nil {
		stringBuilder.WriteString("// Errors encountered during parsing:\n")
		for _, parseErr := range errorwrap.UnwrapErrors(err) {
			stringBuilder.WriteString("//     " + parseErr.Error() + "\n")
		}
	}

	destinationFile.WriteString(stringBuilder.String())
	destinationFile.Close()
	fmt.Printf("Script imported successfully to %s\n", destinationFilePath)
	os.Exit(0)
}

type parserConfig struct {
	commentPrefix         string   // Line prefix for comments ('#' in PS/POSIX shell)
	nonLineBreakingTokens []string // Tokens that should not break lines ("if/then" in POSIX shell or "{" in most shells)
	lineEndingToken       string   // Token used for signifying the end of a line without a line break (";" in PS/POSIX shell)
}

type parsedLine struct {
	line                 string
	isComment            bool
	isLastNonCommentLine bool
}

func snakeCaseToPascalCase(input string) string {
	stringBuilder := &strings.Builder{}

	capitalizeNext := false
	for i, r := range input {
		if r == '_' {
			capitalizeNext = true
			continue
		}

		if capitalizeNext {
			stringBuilder.WriteString(strings.ToUpper(string(r)))
			capitalizeNext = false
			continue
		}

		if i == 0 {
			stringBuilder.WriteString(strings.ToUpper(string(r)))
			continue
		}

		stringBuilder.WriteString(strings.ToLower(string(r)))
	}

	return stringBuilder.String()
}

func parseScriptIntoLines(content []byte, config *parserConfig) ([]string, []parsedLine, bool, error) {
	var err error
	lines := strings.Split(string(content), "\n")
	preScriptComments := []string{}
	parsedLines := make([]parsedLine, 0, len(lines))

	for _, line := range lines {
		line = strings.TrimSpace(line)

		if line == "" {
			continue // Skip empty lines
		}

		if strings.HasPrefix(line, "#!") {
			continue // Skip shebang lines
		}

		if after, ok := strings.CutPrefix(line, config.commentPrefix); ok {
			if len(parsedLines) == 0 {
				preScriptComments = append(preScriptComments, strings.TrimSpace(after))
				continue
			}

			parsedLines = append(parsedLines, parsedLine{
				line:      fmt.Sprintf("//%s", after),
				isComment: true,
			})
			continue
		}

		var processedLine string
		processedLine, err = processScriptLine(line, config)
		parsedLines = append(parsedLines, parsedLine{line: processedLine})
	}

	nonCommentFound := markLastNonCommentLine(parsedLines)

	return preScriptComments, parsedLines, nonCommentFound, err
}

func processScriptLine(line string, config *parserConfig) (string, error) {
	if strings.Contains(line, "`") {
		err := fmt.Errorf("line contains backtick; will attempt to fix it, but it may break Go raw string literal: %s", line)
		line = handleBackticks(line, config)
		return line, err
	}

	// Handle line continuations and endings
	return handleLineEnding(line, config), nil
}

func handleBackticks(line string, config *parserConfig) string {
	line = backtickRegex.ReplaceAllString(line, "` + \"${1}\" + `")

	if strings.HasPrefix(line, "` + \"`") {
		line = strings.TrimPrefix(line, "` + ")
	} else {
		line = fmt.Sprintf("`%s", line)
	}

	if strings.HasSuffix(line, "`\" + `") {
		line = strings.TrimSuffix(line, " + `")
		line = fmt.Sprintf("%s + `%s `", line, config.lineEndingToken)
	} else {
		line = handleLineEnding(line, config)
	}

	return line
}

func markLastNonCommentLine(parsedLines []parsedLine) bool {
	nonCommentFound := false

	for i := len(parsedLines) - 1; i >= 0; i-- {
		if !parsedLines[i].isComment {
			nonCommentFound = true
			parsedLines[i].isLastNonCommentLine = true
			parsedLines[i].line = cleanLastLine(parsedLines[i].line)
			break
		}
	}

	return nonCommentFound
}

func cleanLastLine(line string) string {
	// Handle complex backtick endings
	if strings.HasSuffix(line, "`\" + ` ;`") {
		return strings.TrimSuffix(line, " + ` ;`")
	}

	// Handle semicolon endings
	if strings.HasSuffix(line, "; `") {
		line = strings.TrimSuffix(line, "; `")
		return fmt.Sprintf("%s`", line)
	}

	// Handle space endings
	if strings.HasSuffix(line, " `") {
		line = strings.TrimSuffix(line, " `")
		return fmt.Sprintf("%s`", line)
	}

	return line
}

func handleLineEnding(line string, config *parserConfig) string {
	// Handle line continuation with backslash
	if strings.HasSuffix(line, "\\") {
		line = strings.TrimSuffix(line, "\\")
		line = strings.TrimSpace(line)
		return fmt.Sprintf("`%s `", line)
	}

	// Check if line ends with a non-line-breaking token
	for _, token := range config.nonLineBreakingTokens {
		if strings.HasSuffix(line, token) {
			return fmt.Sprintf("`%s `", line)
		}
	}

	// Default case: add semicolon
	return fmt.Sprintf("`%s%s `", line, config.lineEndingToken)
}

func parseScript(stringBuilder *strings.Builder, parsedLines []parsedLine) {
	for _, pl := range parsedLines {
		stringBuilder.WriteString("    ")

		if pl.isComment {
			stringBuilder.WriteString(pl.line)
			stringBuilder.WriteString("\n")
			continue
		}

		stringBuilder.WriteString(pl.line)

		if !pl.isLastNonCommentLine {
			stringBuilder.WriteString(" +\n")
			continue
		} else {
			stringBuilder.WriteString("\n")
		}
	}
}
