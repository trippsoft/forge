package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
)

const (
	fileHeader = `// Code generated by scriptimport.  DO NOT EDIT.`
)

var (
	supportedExtensions = []string{".sh", ".py", ".ps1"}
	backtickRegex       = regexp.MustCompile("(`+)")
)

func main() {
	args := os.Args[1:]

	if len(args) < 2 {
		println("Usage: scriptimport <package-name> <script-file>")
		os.Exit(1)
	}

	packageName := args[0]
	scriptFilePath := args[1]

	scriptFileName := filepath.Base(scriptFilePath)
	scriptExtension := filepath.Ext(scriptFileName)

	variableName := fmt.Sprintf("%sScript", snakeCaseToCamelCase(strings.TrimSuffix(scriptFileName, scriptExtension)))

	destinationFilePath := fmt.Sprintf("%s.go", scriptFileName)

	destinationFile, err := os.Create(destinationFilePath)
	if err != nil {
		fmt.Printf("Error creating destination file: %v\n", err)
		os.Exit(1)
	}

	stringBuilder := &strings.Builder{}

	stringBuilder.WriteString(fileHeader)

	if !slices.Contains(supportedExtensions, scriptExtension) {
		stringBuilder.WriteString("\n\n// Unsupported script extension: ")
		stringBuilder.WriteString(scriptExtension)
		stringBuilder.WriteString("\n")

		stringBuilder.WriteString("package ")
		stringBuilder.WriteString(packageName)
		stringBuilder.WriteString("\n\n")

		destinationFile.WriteString(stringBuilder.String())
		destinationFile.Close()
		os.Exit(0)
	}

	scriptContent, err := os.ReadFile(scriptFilePath)
	if err != nil {
		stringBuilder.WriteString("// Error reading script file: " + err.Error() + "\n")

		stringBuilder.WriteString("package ")
		stringBuilder.WriteString(packageName)
		stringBuilder.WriteString("\n\n")

		destinationFile.WriteString(stringBuilder.String())
		destinationFile.Close()
		os.Exit(1)
	}

	var preScriptComments []string
	var parsedLines []parsedLine
	var nonCommentFound bool
	var errors []error
	switch scriptExtension {
	case ".sh":
		preScriptComments, parsedLines, nonCommentFound, errors = parseShellScriptIntoLines(scriptContent)
	case ".py":
		preScriptComments, parsedLines, nonCommentFound, errors = parsePythonScriptIntoLines(scriptContent)
	case ".ps1":
		preScriptComments, parsedLines, nonCommentFound, errors = parsePowerShellScriptIntoLines(scriptContent)
	}

	if len(preScriptComments) > 0 {
		stringBuilder.WriteString("\n\n")
	}

	for i, comment := range preScriptComments {
		stringBuilder.WriteString("// ")
		stringBuilder.WriteString(comment)

		if i < len(preScriptComments)-1 {
			stringBuilder.WriteString("\n")
		}
	}

	stringBuilder.WriteString("\n\n")

	stringBuilder.WriteString("package ")
	stringBuilder.WriteString(packageName)
	stringBuilder.WriteString("\n\n")

	if !nonCommentFound {
		stringBuilder.WriteString("// No executable lines found in the script.\n")

		if len(errors) > 0 {
			stringBuilder.WriteString("\n// Errors encountered during parsing:\n")
			for _, parseErr := range errors {
				stringBuilder.WriteString("//     " + parseErr.Error() + "\n")
			}
		}
		destinationFile.WriteString(stringBuilder.String())
		destinationFile.Close()
		os.Exit(0)
	}

	stringBuilder.WriteString("const ")
	stringBuilder.WriteString(variableName)
	stringBuilder.WriteString(" = `` +\n")

	parseScript(stringBuilder, parsedLines)

	if len(errors) > 0 {
		stringBuilder.WriteString("// Errors encountered during parsing:\n")
		for _, parseErr := range errors {
			stringBuilder.WriteString("//     " + parseErr.Error() + "\n")
		}
	}

	destinationFile.WriteString(stringBuilder.String())
	destinationFile.Close()
	fmt.Printf("Script imported successfully to %s\n", destinationFilePath)
	os.Exit(0)
}

type parsedLine struct {
	line                 string
	isComment            bool
	isLastNonCommentLine bool
}

func snakeCaseToCamelCase(input string) string {
	stringbuilder := &strings.Builder{}

	capitalizeNext := false
	for i, r := range input {
		if r == '_' {
			capitalizeNext = true
			continue
		}

		if capitalizeNext {
			stringbuilder.WriteString(strings.ToUpper(string(r)))
			capitalizeNext = false
			continue
		}

		if i == 0 {
			stringbuilder.WriteString(strings.ToLower(string(r)))
			continue
		}

		stringbuilder.WriteString(string(r))
	}

	return stringbuilder.String()
}

func parseShellScriptIntoLines(content []byte) ([]string, []parsedLine, bool, []error) {

	errors := []error{}
	lines := strings.Split(string(content), "\n")
	preScriptComments := []string{}
	parsedLines := make([]parsedLine, 0, len(lines))

	for _, line := range lines {

		line = strings.TrimSpace(line)

		if line == "" || strings.HasPrefix(line, "#!") {
			continue // Skip empty lines or shebang lines
		}

		if after, ok := strings.CutPrefix(line, "#"); ok {

			if len(parsedLines) == 0 {
				preScriptComments = append(preScriptComments, strings.TrimSpace(after))
				continue
			}

			parsedLines = append(parsedLines, parsedLine{
				line:      fmt.Sprintf("//%s", after),
				isComment: true,
			})
			continue
		}

		if strings.Contains(line, "`") {
			errors = append(errors, fmt.Errorf("line contains backtick; will attempt to fix it, but it may break Go raw string literal: %s", line))

			line = backtickRegex.ReplaceAllString(line, "` + \"${1}\" + `")
			if strings.HasPrefix(line, "` + \"`") {
				line = strings.TrimPrefix(line, "` + ")
			} else {
				line = fmt.Sprintf("`%s", line)
			}

			if strings.HasSuffix(line, "`\" + `") {
				line = strings.TrimSuffix(line, " + `")
				line = fmt.Sprintf("%s + `; `", line)
			} else if strings.HasSuffix(line, "\\") {
				line = strings.TrimSuffix(line, "\\")
				line = strings.TrimSpace(line)
				line = fmt.Sprintf("%s `", line)
			} else if strings.HasSuffix(line, "{") || strings.HasSuffix(line, "then") || strings.HasSuffix(line, "else") {
				line = fmt.Sprintf("%s `", line)
			} else {
				line = fmt.Sprintf("%s; `", line)
			}

			parsedLines = append(parsedLines, parsedLine{line: line})
			continue
		}

		if strings.HasSuffix(line, "\\") {
			line = strings.TrimSuffix(line, "\\")
			line = strings.TrimSpace(line)
			line = fmt.Sprintf("%s `", line)
		} else if strings.HasSuffix(line, "{") || strings.HasSuffix(line, "then") || strings.HasSuffix(line, "else") {
			line = fmt.Sprintf("%s `", line)
		} else {
			line = fmt.Sprintf("%s; `", line)
		}

		line = fmt.Sprintf("`%s", line)

		parsedLines = append(parsedLines, parsedLine{line: line})
	}

	nonCommentFound := false
	for i := len(parsedLines) - 1; i >= 0; i-- {
		if !parsedLines[i].isComment {
			nonCommentFound = true

			parsedLines[i].isLastNonCommentLine = true

			if strings.HasSuffix(parsedLines[i].line, "`\" + ` ;`") {
				parsedLines[i].line = strings.TrimSuffix(parsedLines[i].line, " + ` ;`")
			} else if strings.HasSuffix(parsedLines[i].line, "; `") {
				parsedLines[i].line = strings.TrimSuffix(parsedLines[i].line, "; `")
				parsedLines[i].line = fmt.Sprintf("%s`", parsedLines[i].line)
			} else if strings.HasSuffix(parsedLines[i].line, " `") {
				parsedLines[i].line = strings.TrimSuffix(parsedLines[i].line, " `")
				parsedLines[i].line = fmt.Sprintf("%s`", parsedLines[i].line)
			}
			break
		}
	}

	return preScriptComments, parsedLines, nonCommentFound, errors
}

func parsePythonScriptIntoLines(content []byte) ([]string, []parsedLine, bool, []error) {
	panic("unimplemented")
}

func parsePowerShellScriptIntoLines(content []byte) ([]string, []parsedLine, bool, []error) {

	errors := []error{}
	lines := strings.Split(string(content), "\n")
	preScriptComments := []string{}
	parsedLines := make([]parsedLine, 0, len(lines))

	for _, line := range lines {

		line = strings.TrimSpace(line)

		if line == "" || strings.HasPrefix(line, "#!") {
			continue // Skip empty lines or shebang lines
		}

		if after, ok := strings.CutPrefix(line, "#"); ok {

			if len(parsedLines) == 0 {
				preScriptComments = append(preScriptComments, strings.TrimSpace(after))
				continue
			}

			parsedLines = append(parsedLines, parsedLine{
				line:      fmt.Sprintf("//%s", after),
				isComment: true,
			})
			continue
		}

		if strings.Contains(line, "`") {
			errors = append(errors, fmt.Errorf("line contains backtick; will attempt to fix it, but it may break Go raw string literal: %s", line))

			line = backtickRegex.ReplaceAllString(line, "` + \"${1}\" + `")
			if strings.HasPrefix(line, "` + \"`") {
				line = strings.TrimPrefix(line, "` + ")
			} else {
				line = fmt.Sprintf("`%s", line)
			}

			if strings.HasSuffix(line, "`\" + `") {
				line = strings.TrimSuffix(line, " + `")
				line = fmt.Sprintf("%s + `; `", line)
			} else if strings.HasSuffix(line, "\\") {
				line = strings.TrimSuffix(line, "\\")
				line = strings.TrimSpace(line)
				line = fmt.Sprintf("%s `", line)
			} else if strings.HasSuffix(line, "{") {
				line = fmt.Sprintf("%s `", line)
			} else {
				line = fmt.Sprintf("%s; `", line)
			}

			parsedLines = append(parsedLines, parsedLine{line: line})
			continue
		}

		if strings.HasSuffix(line, "\\") {
			line = strings.TrimSuffix(line, "\\")
			line = strings.TrimSpace(line)
			line = fmt.Sprintf("%s `", line)
		} else if strings.HasSuffix(line, "{") {
			line = fmt.Sprintf("%s `", line)
		} else {
			line = fmt.Sprintf("%s; `", line)
		}

		line = fmt.Sprintf("`%s", line)

		parsedLines = append(parsedLines, parsedLine{line: line})
	}

	nonCommentFound := false
	for i := len(parsedLines) - 1; i >= 0; i-- {
		if !parsedLines[i].isComment {
			nonCommentFound = true

			parsedLines[i].isLastNonCommentLine = true

			if strings.HasSuffix(parsedLines[i].line, "`\" + ` ;`") {
				parsedLines[i].line = strings.TrimSuffix(parsedLines[i].line, " + ` ;`")
			} else if strings.HasSuffix(parsedLines[i].line, "; `") {
				parsedLines[i].line = strings.TrimSuffix(parsedLines[i].line, "; `")
				parsedLines[i].line = fmt.Sprintf("%s`", parsedLines[i].line)
			} else if strings.HasSuffix(parsedLines[i].line, " `") {
				parsedLines[i].line = strings.TrimSuffix(parsedLines[i].line, " `")
				parsedLines[i].line = fmt.Sprintf("%s`", parsedLines[i].line)
			}
			break
		}
	}

	return preScriptComments, parsedLines, nonCommentFound, errors
}

func parseScript(stringBuilder *strings.Builder, parsedLines []parsedLine) {

	for _, pl := range parsedLines {

		stringBuilder.WriteString("    ")

		if pl.isComment {
			stringBuilder.WriteString(pl.line)
			stringBuilder.WriteString("\n")
			continue
		}

		stringBuilder.WriteString(pl.line)

		if !pl.isLastNonCommentLine {
			stringBuilder.WriteString(" +\n")
			continue
		} else {
			stringBuilder.WriteString("\n")
		}
	}
}
